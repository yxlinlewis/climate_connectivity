# this is a demo which shows how climate connectivity works
# depth: c('surface','mesopelagic','bathypelagic','abyssopelagic')
# scenario: c('ssp126','ssp245','ssp585')
# year: seq(2021,2100) (baseline year 2020)
# the demo data for running the script can be downloaded elsewhere. See `readme.md`
# setting for demo data: surface - ssp126 and ssp585 in year 2050/2100 as an example
# change the file names as needed

library(magrittr)
library(dplyr)
library(raster)
library(sf)

# here I use packages associated with ArcGIS lisence. Similar functions can be found in other R packages
# library(arcgisbinding)

# direct the dictionary to the `demo` file 
setwd('')

# create folders (change as needed)
dir.create('cc/step1_ptemp_ts')
dir.create('cc/step2_linkage_ts')
dir.create('cc/step3_1_linkage_ts_byp')
dir.create('cc/step3_2_pclimcon_ts')
dir.create('cc/step4_spestat_ts')
for (h in c('surface')){
  dir.create(paste0('cc/step1_ptemp_ts/',h))
  dir.create(paste0('cc/step2_linkage_ts/',h))
  dir.create(paste0('cc/step3_1_linkage_ts_byp/',h))
  dir.create(paste0('cc/step3_2_pclimcon_ts/',h))
  dir.create(paste0('cc/step4_spestat_ts/',h))
  for (s in c('ssp126','ssp585')){
    dir.create(paste0('cc/step1_ptemp_ts/',h,'/',s))
    dir.create(paste0('cc/step2_linkage_ts/',h,'/',s))
    dir.create(paste0('cc/step3_1_linkage_ts_byp/',h,'/',s))
    dir.create(paste0('cc/step3_2_pclimcon_ts/',h,'/',s))
    dir.create(paste0('cc/step4_spestat_ts/',h,'/',s))
  }
}

# The following sections include the full workflow for linkage judgement and connectivity calculation
# Patches identification can be seen in `patch_partitioning` files
# Least-cost pathways were constructed using LinkageMapper toolbox in ArcGIS Pro

# Section1: calculate zonal temperature of all patches ####

for (h in c('surface')){
  # see: patch partition -> 02_patch_proecssing_step1_3_4.ipynb - step3_patches_newid_elim files
  # before proceeding, convert step3_patches_newid_elim (shapefiles) to patch_id (tifs)
  patch <- paste0('cc/patch_id/patch_',h,'_present.tif')
  
  for (s in c('ssp126','ssp585')){
    # create progress bar
    print(paste0('--- ',h,' ',s,' started...'))
    pb <- txtProgressBar(style = 3)
    
    for (yr in seq(2050,2100,50)){
      ## contemporary and future temperature (selected from projected data to ensure consistancy)
      temp <- c(paste0('cmip6/',h,'/',s,'/thetao_',h,'_',s,'_2020.tif'), 
                paste0('cmip6/',h,'/',s,'/thetao_',h,'_',s,'_',yr,'.tif'))
      
      ## load raster stack
      rs <- stack(append(patch, temp)) %>% as.data.frame(., xy=T) %>% .[complete.cases(.),]
      colnames(rs)[3:5] <- c('pid','Present',paste0(s,'_',yr))
      row.names(rs) <- seq(1,nrow(rs))
      
      ## calculate zonal temperature
      dt_temp <- c()
      for (p in unique(rs$pid)){
        patch_temp <- subset(rs, pid == p)
        ### calculate zonal temperature
        dt_temp <- rbind(dt_temp, cbind(pid = p, 
                                        mean(patch_temp[,4], na.rm=T), 
                                        mean(patch_temp[,5], na.rm=T))) %>% as.data.frame()
      }
      colnames(dt_temp) <- c('pid','Present',paste0(s,'_',yr))
      
      ## export data
      to_path <- paste0('cc/step1_ptemp_ts/',h,'/',s,'/ptemp_',h,'_',s,'_',yr,'.csv')
      write.csv(dt_temp, to_path, row.names = F)
      
      # refresh progress bar
      setTxtProgressBar(pb, (yr-2020)/80)
    }
    
    # end progress bar
    close(pb)
  }
}





# Section2: determine flow direction (trajectory & gradient) ####

# activate ArcGIS lisence (if any)
arc.check_product()
for (h in c('surface')){
  # Step1~3: data preprocessing
  if (1){
    # Step1: load corridors results
    # results are generated by ArcGIS Pro Linkage Mapper toolbox
    ## northern hemisphere
    arcf <- arc.open(paste0('LinkageMapper/N_hemisphere/',h,'/link_maps.gdb/present_LCPs'))
    N_link <- arc.select(arcf, fields=c('From_Core','To_Core','CW_Dist','LCP_Length')) %>% 
      as.data.frame(.)
    colnames(N_link)[1:2] <- c('coreId1','coreId2')
    ## southern hemisphere
    arcf <- arc.open(paste0('LinkageMapper/S_hemisphere/',h,'/link_maps.gdb/present_LCPs'))
    S_link <- arc.select(arcf, fields=c('From_Core','To_Core','CW_Dist','LCP_Length')) %>% 
      as.data.frame(.)
    colnames(S_link)[1:2] <- c('coreId1','coreId2')
    
    
    # Step2: generate unique linkage of two hemisphere
    ## combine hemispheres and create new linkage table
    linkage <- rbind(N_link, S_link)
    link_new <- c()
    for (p in unique(linkage$coreId1)){
      link_ext <- subset(linkage, coreId1==p)
      
      ## extract repeated linkage
      if (length(unique(link_ext$coreId2)) < length(link_ext$coreId2)){
        for (rep in unique(link_ext$coreId2)){
          ## judge repeated pairs
          link_rep <- subset(link_ext, coreId2==rep)
          if (nrow(link_rep) > 1){
            ### calculate mean cost-weighted distance and LCP length
            CWD_m <- mean(link_rep$CW_Dist)
            LCP_m <- mean(link_rep$LCP_Length)
            ### combine to new table
            link_new <- rbind(link_new, cbind(coreId1=p,
                                              coreId2=rep,
                                              CW_Dist=CWD_m,
                                              LCP_Length=LCP_m))
          }else{link_new <- rbind(link_new, link_rep)} ## combine to new table without changes
        }
      }else{link_new <- rbind(link_new, link_ext)} ## combine to new table without changes
    }
    rm(arcf, N_link, S_link, link_ext, link_rep, CWD_m, LCP_m, p, rep, linkage)
    
    
    # Step3: add disconnected patches to linkage table
    ## list of all connected patches
    con_pch <- unique(append(link_new$coreId1, link_new$coreId2))
    
    ## list of all patches
    # see: patch partition -> 02_patch_proecssing_step1_3_4.ipynb - step3_patches_newid_elim files (shapefiles)
    all_pch <- st_read(paste0('cc/patch_id/patch_',h,'_present_elim.shp')) %>% .$pid
    
    ## add all patches connected to themselves, with zero distance
    link_new <- rbind(link_new, cbind(coreId1=all_pch,
                                      coreId2=all_pch,
                                      CW_Dist=0,
                                      LCP_Length=0))
    
    ## order by patch ID
    link_new <- link_new[order(link_new$coreId1,link_new$coreId2),]
    row.names(link_new) <- seq(1,nrow(link_new))
  }
  
  # Step4: mesh linkage by climate trajectory and thermal gradient
  for (s in c('ssp126','ssp585')){
    ## load velocity trajectory data (see `climate_velocity` for details)
    traj <- read.csv(paste0('vocc/step4_trajpchs/',h,'/traj_',h,'_',s,'_2020_2100.csv'))
    
    ## mesh linkage by velocity trajectory
    link_traj <- data.frame()
    
    for (r in 1:nrow(link_new)){
      core1 <- link_new[r,1]
      core2 <- link_new[r,2]
      
      ### only connections reachable by velocity trajectory are kept
      if (length(which(traj$from_patch==core1 & traj$to_patch==core2))>0){
        link_traj <- rbind(link_traj, cbind(Origin=core1, 
                                            Dest=core2,
                                            CW_Dist=link_new[r,3],
                                            LCP_Length=link_new[r,4]))
      }else if (length(which(traj$from_patch==core2 & traj$to_patch==core1))>0){
        link_traj <- rbind(link_traj, cbind(Origin=core2, 
                                            Dest=core1,
                                            CW_Dist=link_new[r,3],
                                            LCP_Length=link_new[r,4]))
      }
    }
    
    # create progress bar
    print(paste0('--- ',h,' ',s,' started...'))
    pb <- txtProgressBar(style = 3)
    
    for (yr in seq(2050,2100,50)){
      link <- link_traj
      
      ## load temperature data
      temp <- read.csv(paste0('cc/step1_ptemp_ts/',h,'/',s,'/ptemp_',h,'_',s,'_',yr,'.csv'))
      
      ## join present origin temperature to linkage table
      temp_selc <- temp[,c(1,2)]
      colnames(temp_selc)[1] <- 'Origin'
      link <- left_join(link, temp_selc, by = 'Origin')
      
      ## join present and future destination temperature to linkage table
      temp_selc <- temp
      colnames(temp_selc)[1] <- 'Dest'
      link <- left_join(link, temp_selc, by = 'Dest')
      colnames(link)[5:7] <- c('Origin_pre','Dest_pre','Dest_fut')
      
      ## reorder by patch ID
      link <- link[order(link$Origin,link$Dest),]
      row.names(link) <- seq(1,nrow(link))
      
      ## mesh linkage by thermal gradient
      ### calculate temperature differences between core pairs 
      link$TempDif <- link$Origin_pre - link$Dest_pre
      ### only connections reachable by thermal gradient (not less than 0) are kept
      link_traj_temp <- subset(link, TempDif>=0)
      link_traj_temp <- link_traj_temp[,1:7]
      
      ## export data
      write.csv(link_traj_temp, paste0('cc/step2_linkage_ts/',h,'/',s,'/link_',h,'_',s,'_',yr,'.csv'), row.names = F)
      
      # refresh progress bar
      setTxtProgressBar(pb, (yr-2020)/80)
    }
    
    # end progress bar
    close(pb)
  }
}


# Section 3: determine routes and climate connectivity ####

for (h in c('surface')){
  for (s in c('ssp126','ssp585')){
    for (yr in seq(2050,2100,50)){
      # load linkage data
      link <- read.csv(paste0('cc/step2_linkage_ts/',h,'/',s,'/link_',h,'_',s,'_',yr,'.csv'))
      
      # create temperature table
      temp_pre <- cbind(From=link$Origin, From_pre=link$Origin_pre) %>% 
        unique() %>% as.data.frame()
      temp_fut <- cbind(To=link$Dest, To_fut=link$Dest_fut) %>% 
        unique() %>% as.data.frame()
      
      cc_patch <- c() %>% as.data.frame()
      
      # start progress bar
      print(paste0('----Start: ',h,'-',s,'-',yr,'----'))
      pb <- txtProgressBar(style = 3)
      
      for (p in unique(link$Origin)){
        # Step1: exhaust all possible routes for migration (LCP only)
        
        ## calculate number of loops
        to_p <- subset(link, Origin==p)$Dest
        loop <- 1
        route <- cbind(From=p,To_1=to_p) %>% as.data.frame()
        
        ## exhaustion of all possible combinations
        repeat{
          new_to_p <- to_p
          for (rec in to_p){new_to_p <- append(new_to_p, subset(link, Origin==rec)$Dest)}
          new_to_p <- unique(new_to_p)
          
          if (length(new_to_p)==length(to_p)){break}else{
            loop=loop+1
            
            ## add to new routine table
            route_add <- cbind(route, -1)
            colnames(route_add)[ncol(route_add)] <- 'To'
            for (n in new_to_p){
              if (n %in% to_p == F){
                route_add <- rbind(route_add, cbind(route,To=n))
              }
            }
            route_add <- subset(route_add, To>0)
            colnames(route_add)[ncol(route_add)] <- paste0('To_',loop)
            row.names(route_add) <- seq(1,nrow(route_add))
            
            ## eliminate wrong pairs (comparing with linkage table)
            for (c in 2:(ncol(route_add)-1)){
              ### scan all routes
              for (r in 1:nrow(route_add)){
                from=route_add[r,c] %>% as.numeric()
                to=route_add[r,c+1] %>% as.numeric()
                ### set NA for wrong routes
                if (length(which(link$Origin==from & link$Dest==to))==0){
                  route_add[r,(c+1):ncol(route_add)] <- NA
                }
              }
              ### eliminate duplicate records
              route_add <- unique(route_add)
              row.names(route_add) <- seq(1,nrow(route_add))
            }
            
            ## renew
            to_p=new_to_p
            route <- route_add
          }
        }
        
        ## calculate number of step stones
        steps <- ncol(route)-1
        
        
        
        # Step2: calculate climate connectivity
        
        ## join present origin temperature to routine table
        route_cc <- route
        route_cc <- left_join(route_cc, temp_pre, by = 'From')
        
        ## join future destination temperature to routine table
        for (c in 2:(steps+1)){
          colnames(route_cc)[c] <- 'To'
          route_cc <- left_join(route_cc, temp_fut, by = 'To')
          colnames(route_cc)[c(c,(c+steps+1))] <- c(paste0('To_',(c-1)),paste0('To_fut_',(c-1)))
        }
        
        ## export linkage data by patches
        write.csv(route_cc, 
                  paste0('cc/step3_1_linkage_ts_byp/',h,'/',s,'/',yr,'/',p,'.csv'),
                  row.names = F)
        
        
        ## calculate climate connectivity of each designated end patch
        for (c in (steps+3):ncol(route_cc)){
          for (r in which(is.na(route_cc[,c])==F)){
            route_cc[r,c] <- route_cc$From_pre[r]-route_cc[r,c]
          }
        }
        route_cc <- route_cc[,-(steps+2)]
        
        ## select maximum climate connectivity (capacity to sustain climate-driven migration)
        max_cc <- route_cc[,(steps+2):ncol(route_cc)] %>% 
          as.matrix() %>% as.numeric() %>% na.omit() %>% max()
        
        ## combine tables
        cc_patch <- rbind(cc_patch, cbind(patch=p, ClimCon=max_cc))
        
        
        # refresh progress bar
        setTxtProgressBar(pb, p/length(unique(link$Origin)))
      }
      
      # end progress bar
      close(pb)
      
      # left-join the connectivity results with patch x-y coordinates
      patch <- raster(paste0('cc/patch_id/patch_',h,'_present.tif')) %>% 
        as.data.frame(., xy=T) %>% .[complete.cases(.),]
      colnames(patch)[3] <- 'patch'
      patch <- left_join(patch, cc_patch, by = 'patch')
      
      # export as raster files
      rs.sp <- st_as_sf(patch, coords = c('x','y'), crs=4326) %>% 
        as(., "Spatial") 
      raster(crs = crs(rs.sp), vals = 0, resolution = c(1, 1), ext = extent(c(-180, 180, -90, 90))) %>%
        rasterize(rs.sp, ., field='ClimCon', fun='first') %>% 
        writeRaster(., paste0('cc/step3_2_pclimcon_ts/',h,'/',s,'/pclimcon_',h,'_',s,'_',yr,'.tif'), overwrite=T)
      
      print(paste0('----Complete: ',h,'-',s,'-',yr,'----'))
    }
  }
}





# Section 4: calculate warming experienced by species (time-series, summary) ####

# load thermal tolerance edge of each species (see `climate_impact_tolerance` for details)
edge <- read.csv('cc/Tedge.csv')

for (h in c('surface')){
  # load species overlaps with patches (see the script `species_patch_overlap`)
  spelist <- list.files(paste0('cc/patch_species/',h), 
                        full.names = T, recursive = T, pattern = '.csv$')
  
  # load patch
  patch_cp <- st_read(paste0('cc/patch_id/patch_',h,'_present_elim.shp')) %>% as.data.frame()
  patch_cp <- patch_cp[,3:4]
  
  for (s in c('ssp126','ssp585')){
    for (yr in seq(2050,2100,50)){
      # load LCP data
      LCP_list <- read.csv(paste0('cc/step2_linkage_ts/',h,'/',s,'/link_',h,'_',s,'_',yr,'.csv'))
      
      stat <- c()
      
      # create progress bar
      print(paste0('--- ',s,' ',h,' ',yr,' started...'))
      pb <- txtProgressBar(style = 3)
      
      for (spe in spelist){
        spe_cc <- c() %>% as.data.frame()
        
        ## extract species information
        phy <- strsplit(spe, '/')[[1]][3]
        spename <- strsplit(strsplit(spe, '/')[[1]][5],'.csv$')[[1]][1]
        
        ## tolerance limits
        low_end <- edge$lower_sd[which(edge$species==spename)]
        high_end <- edge$upper_sd[which(edge$species==spename)]
        
        ## load distribution data
        spe_bypatch <- read.csv(spe)
        
        ### start with different destinations
        for (pch in unique(spe_bypatch$pid)){
          ### y-centroid of origin
          cp_origin=patch_cp$cp_y[which(patch_cp$pid==pch)]
          
          ### extract species within each patch
          spe_bp <- subset(spe_bypatch, pid==pch)
          
          ### load linkage data
          links <- read.csv(paste0('cc/step3_1_linkage_ts_byp/',h,'/',s,'/',yr,'/',pch,'.csv'))
          
          ### extract designated patches that within tolerance edges
          Dest_temp <- links[,(ncol(links)/2+2):ncol(links)] %>% 
            as.matrix() %>% as.numeric() %>% na.omit() %>% unique()
          
          ### calculate climate connectivity 
          if (length(which(Dest_temp>=low_end & Dest_temp<=high_end))>0){ #### has suitable destinations
            #### climate connectivity traverse
            Dest_temp <- Dest_temp[which(Dest_temp>=low_end & Dest_temp<=high_end)] #### highest extremes (capability)
            
            # current temperature (original patch)
            Origin_temp <- unique(links$From_pre)
            cc_all <- Origin_temp - Dest_temp
            
            if (length(which(cc_all>0))>0){
              # have suitable habitat and positive connectivity
              # minimized temperature difference (not the maximum capacity!)
              Dest_temp <- unique(Dest_temp[which(cc_all==min(cc_all[which(cc_all>0)]))])
            }else{
              # have suitable habitat but negative connectivity
              Dest_temp <- min(Dest_temp)
            }
            
            # calculate realized connectivity
            spe_bp$ClimCon <- Origin_temp - Dest_temp
            
          }else{ #### has no suitable destinations
            #### targeted patches with lowest extremes (minimized stress)
            dest_id <- which(abs(unique(links$From_pre)-Dest_temp)==min(abs(unique(links$From_pre)-Dest_temp)))
            #### calculation
            Dest_temp <- Dest_temp[dest_id]
            spe_bp$ClimCon <- abs(unique(links$From_pre)-Dest_temp)*(-1)
            
          }
          
          ### calculate connectivity coefficient with LCP pathways
          dest_fut <- links[,(ncol(links)/2+2):ncol(links)] %>% as.matrix()
          dest_fut_id <- links[,2:(ncol(links)/2)] %>% as.matrix()
          conn_coef <- c()
          
          dest_id <- unique(dest_fut_id[which(dest_fut==Dest_temp)])
          trim <- c()
          for (c in 1:ncol(dest_fut)){
            if (length(which(dest_fut_id[,c]==dest_id))>0){
              trim <- append(trim,c)
            }
          }
          
          routes <- links[,1:(max(trim)+1)] %>% unique()
          routes_dest <- routes[,-1] %>% as.data.frame()
          
          for (r in 1:nrow(routes)){
            cum_CWD <- 0
            cum_LCP <- 0
            if (length(which(routes_dest[r,]==dest_id))>0){
              pathway_id <- routes[r,1:(which(routes_dest[r,]==dest_id)+1)] %>% as.numeric()
              
              #### calculate cumulative LCP and CWD
              for (k in 1:(length(pathway_id)-1)){
                from_p <- pathway_id[k]
                to_p <- pathway_id[k+1]
                cum_CWD <- cum_CWD + LCP_list$CW_Dist[which(LCP_list$Origin==from_p & LCP_list$Dest==to_p)]
                cum_LCP <- cum_LCP + LCP_list$LCP_Length[which(LCP_list$Origin==from_p & LCP_list$Dest==to_p)]
              }
              
              ### y-centroid of destination
              cp_dest=patch_cp$cp_y[which(patch_cp$pid==pathway_id[k+1])]
              
              #### calculate resistance coefficiency (greater, harsher)
              if (cum_LCP==0){
                conn_coef <- rbind(conn_coef, 
                                   cbind(LCP_length=cum_LCP, CWDist=cum_CWD, ccef=1, 
                                         y_shift=cp_dest-cp_origin)) %>% as.data.frame()
              }else{
                conn_coef <- rbind(conn_coef, 
                                   cbind(LCP_length=cum_LCP, CWDist=cum_CWD, ccef=cum_CWD/cum_LCP, 
                                         y_shift=cp_dest-cp_origin)) %>% as.data.frame()
              }
            }
          }
          conn_coef <- conn_coef[which(conn_coef$ccef==min(conn_coef$ccef)),]
          # summarize cumulative LCP length (Euclidean distance), cost distance, latitudinal shift
          spe_bp <- cbind(spe_bp, 
                          ResCoef=as.numeric(unique(conn_coef$ccef)), 
                          cumLCP=as.numeric(unique(conn_coef$LCP_length)), 
                          cumCWD=as.numeric(unique(conn_coef$CWDist)), 
                          y_shift=as.numeric(unique(conn_coef$y_shift)))
          
          ### combine table
          spe_cc <- rbind(spe_cc, spe_bp)
        }
        
        ### export as csv files
        spe_cc <- spe_cc[,-3]
        spe_cc$ClimCon[which(spe_cc$ClimCon>0)] <- 0
        stat <- rbind(stat, 
                      cbind(Depth=h,Scenario=s,Year=yr,Species=spename,
                            Unconn=length(which(spe_cc$ClimCon<0))/nrow(spe_cc),
                            Warming=mean(spe_cc$ClimCon, na.rm=T), 
                            cumLCP=mean(spe_cc$cumLCP, na.rm=T), 
                            cumCWD=mean(spe_cc$cumCWD, na.rm=T), 
                            Rescoef=mean(spe_cc$ResCoef, na.rm=T),
                            Latshift=mean(spe_cc$y_shift, na.rm=T))) %>% 
          as.data.frame()
        
        # refresh progress bar
        setTxtProgressBar(pb, which(spelist==spe)/length(spelist))
      }
      
      # end progress bar
      close(pb)
      
      write.csv(stat, paste0('cc/step4_spestat_ts/',h,'/',s,'/Spestat_',h,'_',s,'_',yr,'.csv'), 
                row.names = F)
    }
    
  }
  
}






